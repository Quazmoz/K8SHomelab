# Context Forge Server Registration Init Job
# Automatically registers MCP servers after Context Forge starts
# This Job runs once per deployment (using ttlSecondsAfterFinished for cleanup)
apiVersion: v1
kind: ConfigMap
metadata:
  name: context-forge-init-scripts
  namespace: apps
data:
  register_servers.py: |
    import json
    import os
    import sys
    import subprocess
    import requests
    import time

    API_URL = "http://context-forge.apps.svc.cluster.local:4444"
    
    # 1. Backend MCP Servers (Sources)
    MCP_BACKENDS = [
        # Azure MCP (HTTP)
        {
            "name": "azure-go",
            "url": "http://azure-mcp-go.apps.svc.cluster.local:8080/mcp",
            "destination_url": "http://azure-mcp-go.apps.svc.cluster.local:8080/mcp", 
            "type": "http"
        },
        # GroupMe MCP (SSE)
        {
            "name": "groupme",
            "url": "http://groupme-backend.apps.svc.cluster.local:5000/sse",
            "destination_url": "http://groupme-backend.apps.svc.cluster.local:5000/sse",
            "type": "sse",
            "passthrough_headers": ["X-Authenticated-User"]
        },
        # ClickUp MCP (SSE)
        {
            "name": "clickup-native",
            "url": "http://clickup-mcp-server.apps.svc.cluster.local:5000/sse",
            "destination_url": "http://clickup-mcp-server.apps.svc.cluster.local:5000/sse",
            "type": "sse"
        }
    ]
    
    # 2. Virtual Server Configurations (what OpenWebUI sees)
    # Each virtual server bundles tools from specific backend servers
    VIRTUAL_SERVERS = [
        {
            "name": "azure mcp",
            "description": "Azure cloud resource management tools",
            "backend_servers": ["azure-go"]
        },
        {
            "name": "clickup mcp",
            "description": "ClickUp task and project management tools",
            "backend_servers": ["clickup-native"]
        }
    ]

    def wait_for_context_forge():
        print("‚è≥ Waiting for Context Forge to be ready...")
        for i in range(60):
            try:
                resp = requests.get(f"{API_URL}/health", timeout=5)
                if resp.status_code == 200:
                    print("‚úÖ Context Forge is ready!")
                    return True
            except Exception:
                pass
            time.sleep(5)
        print("‚ùå Context Forge did not become ready")
        return False

    def get_token():
        secret = os.environ.get("JWT_SECRET_KEY", "")
        if not secret:
            print("‚ùå JWT_SECRET_KEY not set")
            sys.exit(1)
        try:
            # Generate admin token
            result = subprocess.check_output([
                sys.executable, "-m", "mcpgateway.utils.create_jwt_token",
                "--username", "admin@localhost",
                "--exp", "0",
                "--secret", secret
            ], text=True, stderr=subprocess.DEVNULL).strip()
            for line in result.split('\n'):
                if line.startswith('eyJ'):
                    return line
            return result
        except Exception as e:
            print(f"‚ùå Token generation failed: {e}")
            sys.exit(1)

    def run_registration(token):
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        
        # --- Step 1: Register Backend MCP Servers ---
        print(f"\nüì° Step 1: Registering Backend MCP Servers...")
        for backend in MCP_BACKENDS:
            print(f"   üëâ Registering Backend: {backend['name']}...")
            try:
                # Try unwrapped first (User hint), fallback to wrapped if failed
                payload = backend
                resp = requests.post(f"{API_URL}/servers", headers=headers, json=payload)
                
                # Check if it was a validation error requiring wrapper
                if resp.status_code == 422: # Validation Error
                     print("      ‚ö†Ô∏è  Unwrapped failed, trying wrapped {'server': ...}...")
                     resp = requests.post(f"{API_URL}/servers", headers=headers, json={"server": backend})

                if resp.status_code in [200, 201]:
                    print(f"      ‚úÖ Registered")
                elif resp.status_code == 409:
                    print(f"      üîπ Already Exists")
                else:
                    print(f"      ‚ö†Ô∏è  Failed: {resp.status_code} - {resp.text[:100]}")
            except Exception as e:
                print(f"      ‚ùå Network Error: {e}")

        # Wait a moment for async tool discovery
        print("   ‚è≥ Waiting 5s for tool discovery...")
        time.sleep(5)

        # --- Step 2: Discover Tools by Backend Server ---
        print(f"\nüîç Step 2: Discovering Tools by Backend Server...")
        tool_map = {}  # Maps backend server name -> list of tool IDs
        
        # Get all tools from the global tools endpoint
        all_tools = []
        try:
            resp = requests.get(f"{API_URL}/tools", headers=headers)
            if resp.status_code == 200:
                all_tools = resp.json()
                print(f"      Found {len(all_tools)} tools total")
        except Exception as e:
            print(f"      ‚ö†Ô∏è  Error getting tools: {e}")
        
        # Group tools by backend server matching
        # Tools are named like "azure-*", "groupme-*", "clickup-*"
        if all_tools:
            print(f"      Grouping tools by backend server...")
            
            for backend_config in MCP_BACKENDS:
                backend_name = backend_config['name']
                backend_prefix = backend_name.split('-')[0]  # Get "azure", "groupme", "clickup"
                
                # Find tools matching this backend's prefix (e.g. "clickup" in "clickup_native_...")
                matching_tools = []
                for tool in all_tools:
                    tool_name = tool.get('name', '').lower()
                    # Check prefix or if backend name part exists in tool name
                    if backend_prefix in tool_name or backend_name.replace('-', '_') in tool_name:
                        matching_tools.append(tool['id'])
                
                tool_map[backend_name] = matching_tools
                if matching_tools:
                    print(f"      ‚úì {backend_name}: {len(matching_tools)} tools found")
            
            # If we still have 0 tools matched, assign all to first backend as fallback
            total_assigned = sum(len(ids) for ids in tool_map.values())
            if total_assigned == 0 and all_tools:
                print(f"      ‚ö†Ô∏è  No pattern matches found, assigning all {len(all_tools)} tools to primary backend")
                if 'azure-go' in tool_map or len(MCP_BACKENDS) > 0:
                    primary_backend = 'azure-go' if 'azure-go' in tool_map else MCP_BACKENDS[0]['name']
                    tool_map[primary_backend] = [tool['id'] for tool in all_tools]
                    print(f"         Assigned {len(all_tools)} tools to {primary_backend}")
        else:
            print(f"      ‚ö†Ô∏è  No tools found in global catalog")
        
        print(f"\n      Tool Map Summary:")
        total_tools = 0
        for server_name, tool_ids in tool_map.items():
            print(f"        {server_name}: {len(tool_ids)} tools")
            total_tools += len(tool_ids)
        print(f"      Total tools to distribute: {total_tools}")

        # --- Step 3: Create/Update Virtual Servers ---
        print(f"\nüì¶ Step 3: Creating/Updating Virtual Servers...", flush=True)
        
        # Fetch existing servers for comparison
        existing_servers = {}
        try:
            srv_resp = requests.get(f"{API_URL}/servers", headers=headers)
            if srv_resp.status_code == 200:
                for s in srv_resp.json():
                    existing_servers[s['name']] = s
        except:
            pass
        
        # Map backend server names to their IDs
        backend_name_to_id = {}
        for name, s in existing_servers.items():
            backend_name_to_id[name] = s.get('id')
        
        print(f"\n      Backend Server ID Map: {backend_name_to_id}")
        
        # Create each virtual server
        for vs_config in VIRTUAL_SERVERS:
            vs_name = vs_config['name']
            vs_desc = vs_config['description']
            backend_servers = vs_config['backend_servers']
            
            # Collect tool IDs from specified backend servers
            associated_tools = []
            for backend in backend_servers:
                if backend in tool_map:
                    associated_tools.extend(tool_map[backend])
            
            print(f"\n   üëâ Virtual Server: '{vs_name}'")
            print(f"      Description: {vs_desc}")
            print(f"      Backend servers: {backend_servers}")
            print(f"      Tools to associate: {len(associated_tools)}")
            if associated_tools:
                print(f"      Tool IDs: {associated_tools[:5]}{'...' if len(associated_tools) > 5 else ''}")
            
            vs_payload = {
                "name": vs_name,
                "description": vs_desc,
                "associatedTools": associated_tools
            }
            
            server_id = None
            if vs_name in existing_servers:
                server_id = existing_servers[vs_name].get('id')
            
            try:
                if server_id:
                    print(f"      Updating existing Virtual Server ({server_id})...", flush=True)
                    resp = requests.put(f"{API_URL}/servers/{server_id}", headers=headers, json=vs_payload)
                    if resp.status_code == 422 or resp.status_code == 404:
                        resp = requests.put(f"{API_URL}/servers/{server_id}", headers=headers, json={"server": vs_payload})
                else:
                    print(f"      Creating new Virtual Server...", flush=True)
                    resp = requests.post(f"{API_URL}/servers", headers=headers, json=vs_payload)
                    if resp.status_code == 422:
                        resp = requests.post(f"{API_URL}/servers", headers=headers, json={"server": vs_payload})
                
                if resp.status_code in [200, 201]:
                    data = resp.json()
                    if 'server' in data:
                        data = data['server']
                    
                    uuid = data.get('uuid') or data.get('id')
                    print(f"      ‚úÖ SUCCESS! Virtual Server '{vs_name}' ready.", flush=True)
                    print(f"      üîë UUID: {uuid}", flush=True)
                else:
                    print(f"      ‚ö†Ô∏è  Failed: {resp.status_code} - {resp.text[:200]}", flush=True)
            except Exception as e:
                print(f"      ‚ùå Error managing Virtual Server: {e}", flush=True)

    if __name__ == "__main__":
        if wait_for_context_forge():
            token = get_token()
            run_registration(token)
        else:
            sys.exit(1)

---
apiVersion: batch/v1
kind: Job
metadata:
  name: context-forge-init-v3
  namespace: apps
  labels:
    app: context-forge-init
spec:
  ttlSecondsAfterFinished: 300  # Clean up 5 min after completion
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: register
        image: ghcr.io/ibm/mcp-context-forge:1.0.0-BETA-1
        command: ["/app/.venv/bin/python3"]
        args: ["/scripts/register_servers.py"]
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: JWT_SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: context-forge-secrets
              key: JWT_SECRET_KEY
        # Azure Credentials for registration
        - name: AZURE_TENANT_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_TENANT_ID
              optional: true
        - name: AZURE_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_CLIENT_ID
              optional: true
        - name: AZURE_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_CLIENT_SECRET
              optional: true
        - name: AZURE_SUBSCRIPTION_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_SUBSCRIPTION_ID
              optional: true
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: context-forge-init-scripts
