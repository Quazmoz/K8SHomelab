# Context Forge Server Registration Init Job
# Automatically registers MCP servers after Context Forge starts
# This Job runs once per deployment (using ttlSecondsAfterFinished for cleanup)
apiVersion: v1
kind: ConfigMap
metadata:
  name: context-forge-init-scripts
  namespace: apps
data:
  register_servers.py: |
    import json
    import os
    import sys
    import subprocess
    import requests
    import time

    API_URL = "http://context-forge.apps.svc.cluster.local:4444"
    
    # 1. Backend MCP Servers (Sources)
    MCP_BACKENDS = [
        # Azure MCP (HTTP)
        {
            "name": "azure-go",
            "url": "http://azure-mcp-go.apps.svc.cluster.local:8080/mcp",
            "destination_url": "http://azure-mcp-go.apps.svc.cluster.local:8080/mcp", 
            "type": "http"
        },
        # GroupMe MCP (SSE)
        {
            "name": "groupme",
            "url": "http://groupme-backend.apps.svc.cluster.local:5000/sse",
            "destination_url": "http://groupme-backend.apps.svc.cluster.local:5000/sse",
            "type": "sse",
            "passthrough_headers": ["X-Authenticated-User"]
        },
        # ClickUp MCP (SSE)
        {
            "name": "clickup-native",
            "url": "http://clickup-mcp-server.apps.svc.cluster.local:5000/sse",
            "destination_url": "http://clickup-mcp-server.apps.svc.cluster.local:5000/sse",
            "type": "sse"
        }
    ]
    
    # 2. Virtual Server Configurations (what OpenWebUI sees)
    # Each virtual server bundles tools from specific backend servers
    VIRTUAL_SERVERS = [
        {
            "name": "azure mcp",
            "description": "Azure cloud resource management tools",
            "backend_servers": ["azure-go"]
        },
        {
            "name": "clickup mcp",
            "description": "ClickUp task and project management tools",
            "backend_servers": ["clickup-native"]
        }
    ]

    def wait_for_context_forge():
        print("‚è≥ Waiting for Context Forge to be ready...")
        for i in range(60):
            try:
                resp = requests.get(f"{API_URL}/health", timeout=5)
                if resp.status_code == 200:
                    print("‚úÖ Context Forge is ready!")
                    return True
            except Exception:
                pass
            time.sleep(5)
        print("‚ùå Context Forge did not become ready")
        return False

    def get_token():
        secret = os.environ.get("JWT_SECRET_KEY", "")
        if not secret:
            print("‚ùå JWT_SECRET_KEY not set")
            sys.exit(1)
        try:
            # Generate admin token
            result = subprocess.check_output([
                sys.executable, "-m", "mcpgateway.utils.create_jwt_token",
                "--username", "admin@localhost",
                "--exp", "0",
                "--secret", secret
            ], text=True, stderr=subprocess.DEVNULL).strip()
            for line in result.split('\n'):
                if line.startswith('eyJ'):
                    return line
            return result
        except Exception as e:
            print(f"‚ùå Token generation failed: {e}")
            sys.exit(1)

    def run_registration(token):
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
        
        # --- Step 1: Register Backend MCP Servers ---
        print(f"\nüì° Step 1: Registering Backend MCP Servers...")
        for backend in MCP_BACKENDS:
            print(f"   üëâ Registering Backend: {backend['name']}...")
            try:
                # Try unwrapped first (User hint), fallback to wrapped if failed
                payload = backend
                resp = requests.post(f"{API_URL}/servers", headers=headers, json=payload)
                
                # Check if it was a validation error requiring wrapper
                if resp.status_code == 422: # Validation Error
                     print("      ‚ö†Ô∏è  Unwrapped failed, trying wrapped {'server': ...}...")
                     resp = requests.post(f"{API_URL}/servers", headers=headers, json={"server": backend})

                if resp.status_code in [200, 201]:
                    print(f"      ‚úÖ Registered")
                elif resp.status_code == 409:
                    print(f"      üîπ Already Exists")
                else:
                    print(f"      ‚ö†Ô∏è  Failed: {resp.status_code} - {resp.text[:100]}")
            except Exception as e:
                print(f"      ‚ùå Network Error: {e}")

        # Wait a moment for async tool discovery
        print("   ‚è≥ Waiting 5s for tool discovery...")
        time.sleep(5)

        # --- Step 2: Discover Tools by Backend Server ---
        print(f"\nüîç Step 2: Discovering Tools by Backend Server...")
        tool_map = {}  # Maps backend server name -> list of tool IDs
        backend_server_ids = {}  # Maps backend server name -> server UUID
        
        # First, get all registered servers to map names to IDs
        try:
            resp = requests.get(f"{API_URL}/servers", headers=headers)
            if resp.status_code == 200:
                for server in resp.json():
                    backend_server_ids[server['name']] = server['id']
                    print(f"      Found backend server: {server['name']} (ID: {server['id']})")
        except Exception as e:
            print(f"      ‚ö†Ô∏è  Could not get server list: {e}")
        
        # Get all tools and group by their server ID
        try:
            resp = requests.get(f"{API_URL}/tools", headers=headers)
            if resp.status_code == 200:
                tools = resp.json()
                print(f"      Found {len(tools)} tools total.")
                
                # Group tools by their server ID, then map to server name
                tools_by_server_id = {}
                for tool in tools:
                    server_id = tool.get('server_id') or tool.get('server', {}).get('id', 'unknown')
                    if server_id not in tools_by_server_id:
                        tools_by_server_id[server_id] = []
                    tools_by_server_id[server_id].append(tool['id'])
                
                # Convert server IDs to server names
                for server_id, tool_ids in tools_by_server_id.items():
                    # Find server name by ID
                    server_name = None
                    for name, sid in backend_server_ids.items():
                        if sid == server_id:
                            server_name = name
                            break
                    if not server_name:
                        server_name = f"unknown({server_id})"
                    
                    tool_map[server_name] = tool_ids
                    print(f"      - {len(tool_ids)} tools from {server_name}")
            else:
                print(f"      ‚ùå Failed to list tools: {resp.status_code}")
        except Exception as e:
            print(f"      ‚ùå Error listing tools: {e}")

        print(f"\n      Tool Map Summary:")
        for server_name, tool_ids in tool_map.items():
            print(f"        {server_name}: {len(tool_ids)} tools")

        # --- Step 3: Create/Update Virtual Servers ---
        print(f"\nüì¶ Step 3: Creating/Updating Virtual Servers...", flush=True)
        
        # Fetch existing servers for comparison
        existing_servers = {}
        try:
            srv_resp = requests.get(f"{API_URL}/servers", headers=headers)
            if srv_resp.status_code == 200:
                for s in srv_resp.json():
                    existing_servers[s['name']] = s
        except:
            pass
        
        # Map backend server names to their IDs
        backend_name_to_id = {}
        for backend_name, server_id in backend_server_ids.items():
            backend_name_to_id[backend_name] = server_id
        
        print(f"\n      Backend Server ID Map: {backend_name_to_id}")
        
        # Create each virtual server
        for vs_config in VIRTUAL_SERVERS:
            vs_name = vs_config['name']
            vs_desc = vs_config['description']
            backend_servers = vs_config['backend_servers']
            
            # Collect tool IDs from specified backend servers
            associated_tools = []
            for backend in backend_servers:
                if backend in tool_map:
                    associated_tools.extend(tool_map[backend])
            
            print(f"\n   üëâ Virtual Server: '{vs_name}'")
            print(f"      Description: {vs_desc}")
            print(f"      Backend servers: {backend_servers}")
            print(f"      Tools to associate: {len(associated_tools)}")
            if associated_tools:
                print(f"      Tool IDs: {associated_tools[:5]}{'...' if len(associated_tools) > 5 else ''}")
            
            vs_payload = {
                "name": vs_name,
                "description": vs_desc,
                "associatedTools": associated_tools
            }
            
            server_id = None
            if vs_name in existing_servers:
                server_id = existing_servers[vs_name].get('id')
            
            try:
                if server_id:
                    print(f"      Updating existing Virtual Server ({server_id})...", flush=True)
                    resp = requests.put(f"{API_URL}/servers/{server_id}", headers=headers, json=vs_payload)
                    if resp.status_code == 422 or resp.status_code == 404:
                        resp = requests.put(f"{API_URL}/servers/{server_id}", headers=headers, json={"server": vs_payload})
                else:
                    print(f"      Creating new Virtual Server...", flush=True)
                    resp = requests.post(f"{API_URL}/servers", headers=headers, json=vs_payload)
                    if resp.status_code == 422:
                        resp = requests.post(f"{API_URL}/servers", headers=headers, json={"server": vs_payload})
                
                if resp.status_code in [200, 201]:
                    data = resp.json()
                    if 'server' in data:
                        data = data['server']
                    
                    uuid = data.get('uuid') or data.get('id')
                    print(f"      ‚úÖ SUCCESS! Virtual Server '{vs_name}' ready.", flush=True)
                    print(f"      üîë UUID: {uuid}", flush=True)
                else:
                    print(f"      ‚ö†Ô∏è  Failed: {resp.status_code} - {resp.text[:200]}", flush=True)
            except Exception as e:
                print(f"      ‚ùå Error managing Virtual Server: {e}", flush=True)

    if __name__ == "__main__":
        if wait_for_context_forge():
            token = get_token()
            run_registration(token)
        else:
            sys.exit(1)

---
apiVersion: batch/v1
kind: Job
metadata:
  name: context-forge-init-v3
  namespace: apps
  labels:
    app: context-forge-init
spec:
  ttlSecondsAfterFinished: 300  # Clean up 5 min after completion
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - name: register
        image: ghcr.io/ibm/mcp-context-forge:1.0.0-BETA-1
        command: ["/app/.venv/bin/python3"]
        args: ["/scripts/register_servers.py"]
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: JWT_SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: context-forge-secrets
              key: JWT_SECRET_KEY
        # Azure Credentials for registration
        - name: AZURE_TENANT_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_TENANT_ID
              optional: true
        - name: AZURE_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_CLIENT_ID
              optional: true
        - name: AZURE_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_CLIENT_SECRET
              optional: true
        - name: AZURE_SUBSCRIPTION_ID
          valueFrom:
            secretKeyRef:
              name: azure-mcp-credentials
              key: AZURE_SUBSCRIPTION_ID
              optional: true
        volumeMounts:
        - name: scripts
          mountPath: /scripts
      volumes:
      - name: scripts
        configMap:
          name: context-forge-init-scripts
