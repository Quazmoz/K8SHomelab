# This is a TEMPLATE file. DO NOT commit actual secrets to version control.
# Instead, create secrets using Jenkins or kubectl with actual values.

# To create secrets manually using kubectl:
# kubectl create secret generic zionup-secrets \
#   --from-literal=POSTGRES_PASSWORD=your-password \
#   --from-literal=SECRET_KEY=your-secret-key \
#   --from-literal=GEMINI_API_KEY=your-api-key \
#   --from-literal=EMAIL_HOST_USER=your-email \
#   --from-literal=EMAIL_HOST_PASSWORD=your-email-password \
#   --from-literal=AZURE_AD_TENANT_ID=your-tenant-id \
#   --from-literal=AZURE_AD_CLIENT_ID=your-client-id \
#   --from-literal=AZURE_AD_CLIENT_SECRET=your-client-secret \
#   --namespace=zionup-production

# For local Jenkins deployment, use the Jenkins Kubernetes plugin to create these secrets

---
# Example structure (for reference only - values are placeholders)
apiVersion: v1
kind: Secret
metadata:
  name: zionup-secrets
  namespace: zionup-production
  labels:
    app: zionup
    environment: production
type: Opaque
stringData:
  # Database Credentials
  POSTGRES_PASSWORD: "REPLACE_WITH_ACTUAL_PASSWORD"
  
  # Django Secret Key (generate using: python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())')
  SECRET_KEY: "REPLACE_WITH_ACTUAL_SECRET_KEY"
  
  # Database URL (constructed from credentials)
  DATABASE_URL: "postgresql+asyncpg://pmapp:REPLACE_WITH_ACTUAL_PASSWORD@postgres:5432/pmapp"
  
  # API Keys
  GEMINI_API_KEY: "REPLACE_WITH_ACTUAL_GEMINI_API_KEY"
  
  # Email Credentials
  EMAIL_HOST_USER: "REPLACE_WITH_ACTUAL_EMAIL"
  EMAIL_HOST_PASSWORD: "REPLACE_WITH_ACTUAL_EMAIL_PASSWORD"
  
  # Azure AD Credentials
  AZURE_AD_TENANT_ID: "REPLACE_WITH_ACTUAL_TENANT_ID"
  AZURE_AD_CLIENT_ID: "REPLACE_WITH_ACTUAL_CLIENT_ID"
  AZURE_AD_CLIENT_SECRET: "REPLACE_WITH_ACTUAL_CLIENT_SECRET"
